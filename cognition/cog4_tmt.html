<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Trail Making Test B</title>

  <!-- style.css is at the root, this page is in /course/ -->
  <link rel="stylesheet" href="../style.css" />

  <style>
    :root { --maxw: 1100px; }

    html, body { height: 100%; }
    body { overflow: hidden; }
    @media (max-width: 900px) { body { overflow: auto; } }

    .wrap { max-width: var(--maxw); margin: 0 auto; padding: 14px; height: 100%; box-sizing: border-box; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      background: rgba(248,249,250,0.85); backdrop-filter: blur(10px);
      border: 1px solid var(--border, #e9ecef);
      border-radius: 8px;
      padding: 8px 10px;
      margin-bottom: 10px;
    }
    .brand{ font-weight:650; letter-spacing:.2px; }
    .muted{ opacity:.78; }
    .small{ font-size:12px; }

    .pill-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 7px 11px; border-radius: 16px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(255,255,255,0.9);
      font-size: 13px; color: inherit; cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, background-color .15s ease;
      box-shadow: 0 1px 6px rgba(0,0,0,0.04);
      white-space: nowrap;
    }
    .pill:hover{ transform: translateY(-1px); box-shadow: 0 4px 14px rgba(0,0,0,0.08); }
    .pill.primary{ background: var(--accent, #5bc2e7); color:#fff; border-color: rgba(0,0,0,0.05); }
    .pill.primary:hover{ background:#67c9ea; }
    .pill.danger{ background:#fff; border-color: rgba(220,53,69,0.25); }
    .pill.danger:hover{ background: rgba(220,53,69,0.06); }

    .grid{
      display:grid;
      grid-template-columns: 1.8fr 1fr;
      gap: 10px;
      height: calc(100% - 56px);
      min-height: 520px;
    }
    @media (max-width: 900px){
      body { overflow: auto; }
      .grid{ grid-template-columns: 1fr; height:auto; min-height:0; }
    }

    .card{
      background: rgba(255,255,255,0.95);
      border: 1px solid var(--border, #e9ecef);
      border-radius: 8px;
      box-shadow: 0 2px 14px rgba(0,0,0,0.05);
      padding: 12px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row.spread{ justify-content: space-between; }

    .status{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; font-size:12px; }
    .badge{
      padding: 4px 8px; border-radius: 16px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(248,249,250,0.9);
      white-space: nowrap;
    }
    .badge.ok{ border-color: rgba(25,135,84,0.25); background: rgba(25,135,84,0.08); }
    .badge.bad{ border-color: rgba(220,53,69,0.25); background: rgba(220,53,69,0.08); }

    .kv{ display:grid; grid-template-columns: 1fr auto; gap: 6px 10px; font-size: 12.5px; }
    .kv div:nth-child(odd){ opacity:.78; }

    .arena{
      border: 1px solid var(--border, #e9ecef);
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(248,249,250,0.95), rgba(255,255,255,0.95));
      height: 410px;
      position: relative;
      overflow:hidden;
      user-select:none;
    }
    @media (max-width: 900px){
      .arena{ height: 380px; }
    }

    .node{
      position:absolute;
      width: 46px; height: 46px;
      border-radius: 999px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(255,255,255,0.96);
      box-shadow: 0 1px 8px rgba(0,0,0,0.06);
      display:flex; align-items:center; justify-content:center;
      font-weight: 700;
      cursor:pointer;
      transform: translate(-50%, -50%);
      transition: transform .08s ease, box-shadow .12s ease, background-color .12s ease;
      font-size: 15px;
    }
    .node:hover{ transform: translate(-50%, -50%) scale(1.03); box-shadow: 0 4px 14px rgba(0,0,0,0.10); }
    .node.disabled{ cursor:not-allowed; opacity:.55; }
    .node.active{
      border-color: rgba(91,194,231,0.9);
      box-shadow: 0 0 0 4px rgba(91,194,231,0.22), 0 4px 14px rgba(0,0,0,0.10);
    }
    .node.done{
      background: rgba(25,135,84,0.10);
      border-color: rgba(25,135,84,0.25);
    }

    svg#lines{
      position:absolute; inset:0;
      width:100%; height:100%;
      pointer-events:none;
    }

    .hint{
      margin-top: 8px;
      font-size: 12px;
      opacity: .78;
      line-height: 1.25;
    }

    table{ width:100%; border-collapse: collapse; }
    th, td{ text-align:left; padding: 7px 6px; border-bottom: 1px solid var(--border, #e9ecef); font-size: 12.5px; }
    th{ background: rgba(248,249,250,0.9); font-weight: 650; }
    .right{ text-align:right; }

    .historyBox{
      border:1px solid var(--border, #e9ecef);
      border-radius: 8px;
      overflow:hidden;
      max-height: 210px;
    }

    .footnote{ margin-top: 8px; font-size: 11.5px; opacity: .72; line-height: 1.25; }

    .tinyBtn{
      padding: 7px 10px;
      border-radius: 8px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(255,255,255,0.95);
      cursor:pointer;
      font-size: 12.5px;
      transition: transform .12s ease, box-shadow .12s ease;
      box-shadow: 0 1px 6px rgba(0,0,0,0.04);
    }
    .tinyBtn:hover{ transform: translateY(-1px); box-shadow: 0 4px 14px rgba(0,0,0,0.08); }
    .tinyBtn:disabled{ opacity:.55; cursor:not-allowed; transform:none; box-shadow:none; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <div class="brand">Trail Making Test B</div>
        <div class="muted small">Connect in order: 1–A–2–B–3–C… Tap the next circle. No scrolling.</div>
      </div>

      <div class="pill-row">
        <button id="btnStart" class="pill primary" type="button">Start</button>
        <button id="btnNew" class="pill" type="button">New layout</button>
        <button id="btnExport" class="pill" type="button">Export</button>
        <button id="btnReset" class="pill danger" type="button" title="Clears your saved history">Reset</button>
      </div>
    </div>

    <div class="grid">
      <!-- Main -->
      <section class="card" aria-live="polite">
        <div class="row spread">
          <div class="status">
            <span class="badge" id="badgePhase">Idle</span>
            <span class="badge" id="badgeTime">Time: –</span>
            <span class="badge" id="badgeErrors">Errors: –</span>
          </div>

          <div class="kv" style="min-width:260px;">
            <div>Targets</div><div><span id="targetsLabel">24</span></div>
            <div>Current</div><div><span id="currentLabel">—</span></div>
            <div>Best (today)</div><div><span id="bestLabel">—</span></div>
          </div>
        </div>

        <div style="height:10px;"></div>

        <div class="arena" id="arena">
          <svg id="lines" viewBox="0 0 1000 700" preserveAspectRatio="none"></svg>
        </div>

        <div class="hint">
          Tap the next item. If you tap the wrong one, an error is counted and you must continue with the correct next item.
          The goal is to finish as fast as possible with few errors.
        </div>
      </section>

      <!-- Side -->
      <aside class="card">
        <div class="row spread" style="margin-bottom:8px;">
          <div>
            <div style="font-weight:650;">Results</div>
            <div class="muted small">Saved in your browser (localStorage).</div>
          </div>
          <div class="row" style="gap:8px;">
            <button class="tinyBtn" id="btnPractice" type="button">Practice (8)</button>
            <button class="tinyBtn" id="btnFull" type="button">Full (24)</button>
          </div>
        </div>

        <div class="kv">
          <div>Completion time</div><div id="statTime">–</div>
          <div>Errors</div><div id="statErr">0</div>
          <div>Accuracy</div><div id="statAcc">–</div>
          <div>Path length</div><div id="statPath">–</div>
        </div>

        <div style="height:10px;"></div>

        <div class="kv">
          <div>Latest time</div><div id="latestTime">–</div>
          <div>Latest errors</div><div id="latestErr">–</div>
          <div>Last session</div><div id="latestDate">–</div>
        </div>

        <div style="height:10px;"></div>

        <div style="font-weight:650; font-size:12.5px; margin-bottom:6px;">History</div>
        <div class="historyBox">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th class="right">Time</th>
                <th class="right">Err</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <tr><td colspan="3" class="muted">No sessions yet.</td></tr>
            </tbody>
          </table>
        </div>

        <div class="footnote">
          This is a simplified digital TMT-B. It is useful for repeated within-person tracking.
          Keep the same device and screen size for comparisons.
        </div>
      </aside>
    </div>
  </div>

  <script>
    /********************************************************************
     * Trail Making Test B (digital, compact)
     * - Tap sequence: 1-A-2-B... (interleaved)
     * - Errors counted when wrong node tapped (must keep going)
     * - Lines drawn between correct taps
     * - Practice mode (8 nodes) and Full mode (24 nodes)
     * - localStorage history + JSON export
     ********************************************************************/

    const CONFIG = {
      storageKey: "tmtb.v1",
      arenaW: 1000,
      arenaH: 700,
      nodeSizePx: 46,
      minDist: 72,   // min distance between centers (in arena coords)
      margin: 70,
      maxAttempts: 12000
    };

    const el = {
      btnStart: document.getElementById("btnStart"),
      btnNew: document.getElementById("btnNew"),
      btnExport: document.getElementById("btnExport"),
      btnReset: document.getElementById("btnReset"),

      btnPractice: document.getElementById("btnPractice"),
      btnFull: document.getElementById("btnFull"),

      badgePhase: document.getElementById("badgePhase"),
      badgeTime: document.getElementById("badgeTime"),
      badgeErrors: document.getElementById("badgeErrors"),

      targetsLabel: document.getElementById("targetsLabel"),
      currentLabel: document.getElementById("currentLabel"),
      bestLabel: document.getElementById("bestLabel"),

      statTime: document.getElementById("statTime"),
      statErr: document.getElementById("statErr"),
      statAcc: document.getElementById("statAcc"),
      statPath: document.getElementById("statPath"),

      latestTime: document.getElementById("latestTime"),
      latestErr: document.getElementById("latestErr"),
      latestDate: document.getElementById("latestDate"),
      historyBody: document.getElementById("historyBody"),

      arena: document.getElementById("arena"),
      lines: document.getElementById("lines")
    };

    const state = {
      running: false,
      mode: "full", // "practice" | "full"
      totalTargets: 24,

      // layout
      nodes: [],    // {id, label, x, y, el}
      order: [],    // labels in required order
      currentIndex: 0,
      errors: 0,

      // timing + path
      tStart: null,
      timer: null,
      correctClicks: [], // {x,y, label, t}
      pathLen: 0
    };

    function now() { return Date.now(); }
    function nowISO() { return new Date().toISOString(); }

    function fmtDate(iso) {
      try {
        const d = new Date(iso);
        return d.toLocaleString(undefined, { month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
      } catch { return iso; }
    }

    function fmtMs(ms) {
      const s = ms / 1000;
      if (s < 60) return `${s.toFixed(1)} s`;
      const m = Math.floor(s / 60);
      const r = s - m*60;
      return `${m}:${String(Math.floor(r)).padStart(2,"0")} (${s.toFixed(1)} s)`;
    }

    function setBadge(elm, text, kind=null) {
      elm.textContent = text;
      elm.classList.remove("ok","bad");
      if (kind) elm.classList.add(kind);
    }

    function todayKey() {
      const d = new Date();
      return `${d.getFullYear()}-${String(d.getMonth()+1).padStart(2,'0')}-${String(d.getDate()).padStart(2,'0')}`;
    }

    function loadSessions() {
      try {
        const raw = localStorage.getItem(CONFIG.storageKey);
        if (!raw) return [];
        const data = JSON.parse(raw);
        return Array.isArray(data) ? data : [];
      } catch { return []; }
    }
    function saveSessions(sessions) {
      localStorage.setItem(CONFIG.storageKey, JSON.stringify(sessions));
    }
    function addSession(session) {
      const sessions = loadSessions();
      sessions.unshift(session);
      saveSessions(sessions.slice(0, 200));
      renderHistory();
      renderLatest();
      renderBestToday();
    }

    function renderLatest() {
      const sessions = loadSessions();
      const s = sessions[0] || null;
      el.latestTime.textContent = s ? fmtMs(s.durationMs) : "–";
      el.latestErr.textContent = s ? String(s.errors) : "–";
      el.latestDate.textContent = s ? fmtDate(s.completedAt) : "–";
    }

    function renderBestToday() {
      const sessions = loadSessions().filter(s => s.dayKey === todayKey() && s.mode === state.mode);
      if (!sessions.length) { el.bestLabel.textContent = "—"; return; }
      const best = sessions.reduce((a,b) => (a.durationMs < b.durationMs ? a : b));
      el.bestLabel.textContent = fmtMs(best.durationMs);
    }

    function renderHistory() {
      const sessions = loadSessions().filter(s => s.mode === state.mode);
      const body = el.historyBody;
      body.innerHTML = "";
      if (!sessions.length) {
        body.innerHTML = '<tr><td colspan="3" class="muted">No sessions yet.</td></tr>';
        return;
      }
      for (const s of sessions.slice(0, 6)) {
        const tr = document.createElement("tr");

        const tdDate = document.createElement("td");
        tdDate.textContent = fmtDate(s.completedAt);

        const tdTime = document.createElement("td");
        tdTime.className = "right";
        tdTime.textContent = fmtMs(s.durationMs);

        const tdErr = document.createElement("td");
        tdErr.className = "right";
        tdErr.textContent = String(s.errors);

        tr.appendChild(tdDate);
        tr.appendChild(tdTime);
        tr.appendChild(tdErr);
        body.appendChild(tr);
      }
    }

    function setMode(mode) {
      state.mode = mode;
      state.totalTargets = (mode === "practice") ? 8 : 24;
      el.targetsLabel.textContent = String(state.totalTargets);
      stopToIdle(true);
      newLayout();
      renderHistory();
      renderLatest();
      renderBestToday();
    }

    function requiredOrder(nTargets) {
      // Interleave numbers and letters: 1-A-2-B...
      // nTargets must be even
      const pairs = nTargets / 2;
      const order = [];
      for (let i=1; i<=pairs; i++) {
        order.push(String(i));
        order.push(String.fromCharCode(64 + i)); // A=65
      }
      return order;
    }

    function distance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx*dx + dy*dy);
    }

    function generatePositions(count) {
      const pts = [];
      let attempts = 0;

      while (pts.length < count && attempts < CONFIG.maxAttempts) {
        attempts++;
        const x = CONFIG.margin + Math.random() * (CONFIG.arenaW - 2*CONFIG.margin);
        const y = CONFIG.margin + Math.random() * (CONFIG.arenaH - 2*CONFIG.margin);

        let ok = true;
        for (const p of pts) {
          const dx = p.x - x, dy = p.y - y;
          if ((dx*dx + dy*dy) < (CONFIG.minDist*CONFIG.minDist)) { ok = false; break; }
        }
        if (ok) pts.push({x,y});
      }

      // fallback: if too tight (small screens), relax a bit
      while (pts.length < count) {
        pts.push({
          x: CONFIG.margin + Math.random() * (CONFIG.arenaW - 2*CONFIG.margin),
          y: CONFIG.margin + Math.random() * (CONFIG.arenaH - 2*CONFIG.margin)
        });
      }
      return pts;
    }

    function clearArena() {
      el.arena.querySelectorAll(".node").forEach(n => n.remove());
      el.lines.innerHTML = "";
      state.nodes = [];
    }

    function newLayout() {
      clearArena();

      state.order = requiredOrder(state.totalTargets);

      // create nodes with shuffled positions
      const pts = generatePositions(state.totalTargets);
      const labels = state.order.slice(); // all labels present, order is required order but positions random
      // shuffle labels assignment to positions to avoid any pattern
      const shuffled = labels.slice().sort(() => Math.random() - 0.5);

      const nodes = [];
      for (let i=0; i<state.totalTargets; i++) {
        const label = shuffled[i];
        const p = pts[i];

        const div = document.createElement("div");
        div.className = "node";
        div.textContent = label;
        div.style.left = (p.x / CONFIG.arenaW * 100) + "%";
        div.style.top  = (p.y / CONFIG.arenaH * 100) + "%";
        div.setAttribute("data-label", label);

        div.addEventListener("click", () => onNodeClick(label));

        el.arena.appendChild(div);

        nodes.push({ id: i, label, x: p.x, y: p.y, el: div });
      }

      state.nodes = nodes;

      // highlight first target in required order
      state.currentIndex = 0;
      state.errors = 0;
      state.correctClicks = [];
      state.pathLen = 0;

      updateUIIdle();
      markActiveTarget();
    }

    function getNodeByLabel(label) {
      return state.nodes.find(n => n.label === label);
    }

    function markActiveTarget() {
      state.nodes.forEach(n => n.el.classList.remove("active"));
      const next = state.order[state.currentIndex];
      const node = getNodeByLabel(next);
      if (node) node.el.classList.add("active");
      el.currentLabel.textContent = next || "—";
    }

    function drawLine(a, b) {
      const x1 = a.x / CONFIG.arenaW * 1000;
      const y1 = a.y / CONFIG.arenaH * 700;
      const x2 = b.x / CONFIG.arenaW * 1000;
      const y2 = b.y / CONFIG.arenaH * 700;

      const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
      line.setAttribute("x1", x1);
      line.setAttribute("y1", y1);
      line.setAttribute("x2", x2);
      line.setAttribute("y2", y2);
      line.setAttribute("stroke", "rgba(0,0,0,0.38)");
      line.setAttribute("stroke-width", "3");
      line.setAttribute("stroke-linecap", "round");
      el.lines.appendChild(line);
    }

    function startTest() {
      if (state.running) return;

      state.running = true;
      state.tStart = now();
      setBadge(el.badgePhase, "Running", "ok");
      el.btnStart.textContent = "Restart";

      state.timer = setInterval(() => {
        const t = now() - state.tStart;
        setBadge(el.badgeTime, "Time: " + fmtMs(t));
      }, 100);

      setBadge(el.badgeErrors, "Errors: " + state.errors);
      markActiveTarget();
    }

    function stopToIdle(keepLayout=false) {
      state.running = false;
      if (state.timer) clearInterval(state.timer);
      state.timer = null;

      el.btnStart.textContent = "Start";

      if (!keepLayout) newLayout();
      updateUIIdle();
    }

    function updateUIIdle() {
      setBadge(el.badgePhase, "Idle");
      setBadge(el.badgeTime, "Time: –");
      setBadge(el.badgeErrors, "Errors: " + state.errors);

      el.statTime.textContent = "–";
      el.statErr.textContent = String(state.errors);
      el.statAcc.textContent = "–";
      el.statPath.textContent = "–";

      el.currentLabel.textContent = state.order[state.currentIndex] || "—";
    }

    function finishTest() {
      if (!state.running) return;

      state.running = false;
      if (state.timer) clearInterval(state.timer);
      state.timer = null;

      const durationMs = now() - state.tStart;
      setBadge(el.badgePhase, "Done");
      setBadge(el.badgeTime, "Time: " + fmtMs(durationMs));
      setBadge(el.badgeErrors, "Errors: " + state.errors);

      const totalClicks = state.totalTargets - 1; // correct transitions
      const acc = totalClicks >= 0 ? Math.max(0, (totalClicks) / (totalClicks + state.errors)) : 0;

      el.statTime.textContent = fmtMs(durationMs);
      el.statErr.textContent = String(state.errors);
      el.statAcc.textContent = `${Math.round(acc * 100)}%`;
      el.statPath.textContent = state.pathLen ? `${Math.round(state.pathLen)} px` : "–";

      // store session
      const session = {
        test: "TMT-B",
        mode: state.mode,
        totalTargets: state.totalTargets,
        durationMs,
        errors: state.errors,
        accuracy: acc,
        pathLenPx: Math.round(state.pathLen || 0),
        completedAt: nowISO(),
        dayKey: todayKey(),
        layout: state.nodes.map(n => ({ label:n.label, x:n.x, y:n.y })),
        order: state.order.slice()
      };
      addSession(session);

      // mark all done
      state.nodes.forEach(n => n.el.classList.add("done"));
      state.nodes.forEach(n => n.el.classList.remove("active"));

      el.btnStart.textContent = "Start";
    }

    function onNodeClick(label) {
      // allow clicking to start immediately
      if (!state.running) startTest();

      const expected = state.order[state.currentIndex];
      if (!expected) return;

      if (label !== expected) {
        state.errors += 1;
        setBadge(el.badgeErrors, "Errors: " + state.errors, "bad");
        setTimeout(() => setBadge(el.badgeErrors, "Errors: " + state.errors), 280);
        return;
      }

      // correct click
      const node = getNodeByLabel(label);
      if (!node) return;

      node.el.classList.add("done");
      node.el.classList.remove("active");

      const t = now() - state.tStart;
      const last = state.correctClicks[state.correctClicks.length - 1];

      // draw line from last correct to this one
      if (last) {
        const a = { x: last.x, y: last.y };
        const b = { x: node.x, y: node.y };
        drawLine(a, b);
        state.pathLen += distance(a, b);
      }

      state.correctClicks.push({ x: node.x, y: node.y, label, t });

      state.currentIndex += 1;
      setBadge(el.badgeErrors, "Errors: " + state.errors);

      if (state.currentIndex >= state.order.length) {
        finishTest();
        return;
      }

      markActiveTarget();
    }

    function exportJSON() {
      const sessions = loadSessions();
      const blob = new Blob([JSON.stringify(sessions, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "tmtb-sessions.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // UI events
    el.btnStart.addEventListener("click", () => {
      if (state.running) { stopToIdle(true); startTest(); return; }
      // if already finished, restart with same layout
      stopToIdle(true);
      startTest();
    });

    el.btnNew.addEventListener("click", () => {
      stopToIdle(true);
      newLayout();
    });

    el.btnExport.addEventListener("click", exportJSON);

    el.btnReset.addEventListener("click", () => {
      localStorage.removeItem(CONFIG.storageKey);
      renderHistory();
      renderLatest();
      renderBestToday();
      el.bestLabel.textContent = "—";
      el.latestTime.textContent = "–";
      el.latestErr.textContent = "–";
      el.latestDate.textContent = "–";
    });

    el.btnPractice.addEventListener("click", () => setMode("practice"));
    el.btnFull.addEventListener("click", () => setMode("full"));

    // Init
    (function init() {
      setMode("full");
      renderHistory();
      renderLatest();
      renderBestToday();
    })();
  </script>
</body>
</html>

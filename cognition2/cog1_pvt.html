<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PVT – 5 minutes</title>

  <!-- style.css is at the root, this page is in /course/ -->
  <link rel="stylesheet" href="../style.css" />

  <style>
    :root { --maxw: 1100px; }

    html, body { height: 100%; }
    body { overflow: hidden; }
    @media (max-width: 900px) { body { overflow: auto; } }

    .wrap { max-width: var(--maxw); margin: 0 auto; padding: 14px; height: 100%; box-sizing: border-box; }

    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;
      background: rgba(248,249,250,0.85); backdrop-filter: blur(10px);
      border: 1px solid var(--border, #e9ecef);
      border-radius: 8px;
      padding: 8px 10px;
      margin-bottom: 10px;
    }
    .brand{ font-weight:650; letter-spacing:.2px; }
    .muted{ opacity:.78; }
    .small{ font-size:12px; }

    .pill-row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 7px 11px; border-radius: 16px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(255,255,255,0.9);
      font-size: 13px; color: inherit; cursor: pointer;
      transition: transform .15s ease, box-shadow .15s ease, background-color .15s ease;
      box-shadow: 0 1px 6px rgba(0,0,0,0.04);
      white-space: nowrap;
    }
    .pill:hover{ transform: translateY(-1px); box-shadow: 0 4px 14px rgba(0,0,0,0.08); }
    .pill.primary{ background: var(--accent, #5bc2e7); color:#fff; border-color: rgba(0,0,0,0.05); }
    .pill.primary:hover{ background:#67c9ea; }
    .pill.danger{ background:#fff; border-color: rgba(220,53,69,0.25); }
    .pill.danger:hover{ background: rgba(220,53,69,0.06); }

    .grid{
      display:grid;
      grid-template-columns: 1.7fr 1fr;
      gap: 10px;
      height: calc(100% - 56px);
      min-height: 520px;
    }
    @media (max-width: 900px){
      body { overflow: auto; }
      .grid{ grid-template-columns: 1fr; height:auto; min-height:0; }
    }

    .card{
      background: rgba(255,255,255,0.95);
      border: 1px solid var(--border, #e9ecef);
      border-radius: 8px;
      box-shadow: 0 2px 14px rgba(0,0,0,0.05);
      padding: 12px;
      box-sizing: border-box;
      overflow: hidden;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .row.spread{ justify-content: space-between; }

    .status{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; font-size:12px; }
    .badge{
      padding: 4px 8px; border-radius: 16px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(248,249,250,0.9);
      white-space: nowrap;
    }
    .badge.ok{ border-color: rgba(25,135,84,0.25); background: rgba(25,135,84,0.08); }
    .badge.bad{ border-color: rgba(220,53,69,0.25); background: rgba(220,53,69,0.08); }

    .kv{ display:grid; grid-template-columns: 1fr auto; gap: 6px 10px; font-size: 12.5px; }
    .kv div:nth-child(odd){ opacity:.78; }

    .progress{
      height: 9px; border-radius: 999px;
      background: rgba(222,226,230,0.7);
      overflow: hidden;
      border: 1px solid var(--border, #e9ecef);
      margin-top: 8px;
    }
    .bar{
      height: 100%;
      width: 0%;
      background: var(--accent, #5bc2e7);
      transition: width .12s linear;
    }

    .stage{
      border: 1px solid var(--border, #e9ecef);
      border-radius: 8px;
      background: linear-gradient(180deg, rgba(248,249,250,0.95), rgba(255,255,255,0.95));
      height: 410px;
      position: relative;
      overflow:hidden;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      cursor: pointer;
    }
    @media (max-width: 900px){
      .stage{ height: 380px; }
    }

    .centerBox{
      width: min(520px, 92%);
      border: 1px solid var(--border, #e9ecef);
      border-radius: 12px;
      background: rgba(255,255,255,0.94);
      box-shadow: 0 2px 18px rgba(0,0,0,0.06);
      padding: 18px 16px;
    }

    .big{
      font-size: 72px;
      font-weight: 800;
      letter-spacing: 1px;
      line-height: 1;
      margin: 0;
    }
    .sub{
      margin-top: 10px;
      font-size: 13px;
      opacity: .75;
      line-height: 1.25;
    }

    .tiny{
      font-size: 12px;
      opacity: .78;
      line-height: 1.25;
    }

    .tapHint{
      margin-top: 10px;
      display:inline-flex;
      gap: 8px;
      align-items:center;
      justify-content:center;
      padding: 7px 10px;
      border-radius: 16px;
      border: 1px solid var(--border, #e9ecef);
      background: rgba(248,249,250,0.95);
      font-size: 12.5px;
      opacity: .95;
    }

    table{ width:100%; border-collapse: collapse; }
    th, td{ text-align:left; padding: 7px 6px; border-bottom: 1px solid var(--border, #e9ecef); font-size: 12.5px; }
    th{ background: rgba(248,249,250,0.9); font-weight: 650; }
    .right{ text-align:right; }

    .historyBox{
      border:1px solid var(--border, #e9ecef);
      border-radius: 8px;
      overflow:hidden;
      max-height: 210px;
    }

    .footnote{ margin-top: 8px; font-size: 11.5px; opacity: .72; line-height: 1.25; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="topbar">
      <div>
        <div class="brand">Psychomotor Vigilance Task</div>
        <div class="muted small">5 minutes. Tap as soon as the counter appears. (Spacebar also works.)</div>
      </div>

      <div class="pill-row">
        <button id="btnStart" class="pill primary" type="button">Start</button>
        <button id="btnExport" class="pill" type="button">Export</button>
        <button id="btnReset" class="pill danger" type="button" title="Clears your saved history">Reset</button>
      </div>
    </div>

    <div class="grid">
      <!-- Main -->
      <section class="card" aria-live="polite">
        <div class="row spread">
          <div class="status">
            <span class="badge" id="badgePhase">Idle</span>
            <span class="badge" id="badgeTime">Time: –</span>
            <span class="badge" id="badgeLast">Last RT: –</span>
          </div>

          <div class="kv" style="min-width:260px;">
            <div>Duration</div><div>300 s</div>
            <div>ISI range</div><div><span id="isiLabel">2–10</span> s</div>
            <div>Lapse threshold</div><div><span id="lapseLabel">500</span> ms</div>
          </div>
        </div>

        <div class="progress"><div class="bar" id="timeBar"></div></div>

        <div style="height:10px;"></div>

        <div class="stage" id="stage" aria-label="PVT stage">
          <div class="centerBox">
            <div class="big" id="display">—</div>
            <div class="tapHint" id="tapHint">Tap screen or press Space</div>
            <div class="sub" id="subtext">
              Wait. When numbers appear, react as fast as you can.
              Do not tap before the numbers (false start).
            </div>
          </div>
        </div>

        <div class="footnote">
          Outputs: mean/median RT, lapses (≥ threshold), false starts, fastest 10%, slowest 10%.
          This is an app-style PVT for within-person tracking.
        </div>
      </section>

      <!-- Side -->
      <aside class="card">
        <div class="row spread" style="margin-bottom:8px;">
          <div>
            <div style="font-weight:650;">Session</div>
            <div class="muted small">Saved in your browser (localStorage).</div>
          </div>
          <div class="row" style="gap:8px;">
            <select id="isiSelect" aria-label="ISI range">
              <option value="2,10" selected>2–10 s</option>
              <option value="2,6">2–6 s</option>
              <option value="3,12">3–12 s</option>
            </select>
            <select id="lapseSelect" aria-label="Lapse threshold">
              <option value="355">355 ms</option>
              <option value="500" selected>500 ms</option>
              <option value="700">700 ms</option>
            </select>
          </div>
        </div>

        <div class="kv">
          <div>Trials</div><div id="statTrials">0</div>
          <div>Median RT</div><div id="statMed">–</div>
          <div>Mean RT</div><div id="statMean">–</div>
          <div>Lapses</div><div id="statLapses">0</div>
          <div>False starts</div><div id="statFalse">0</div>
          <div>Fastest 10%</div><div id="statFast">–</div>
          <div>Slowest 10%</div><div id="statSlow">–</div>
        </div>

        <div style="height:10px;"></div>

        <div class="kv">
          <div>Latest median</div><div id="latestMed">–</div>
          <div>Latest lapses</div><div id="latestLapses">–</div>
          <div>Last session</div><div id="latestDate">–</div>
        </div>

        <div style="height:10px;"></div>

        <div style="font-weight:650; font-size:12.5px; margin-bottom:6px;">History</div>
        <div class="historyBox">
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th class="right">Med</th>
                <th class="right">Lapses</th>
              </tr>
            </thead>
            <tbody id="historyBody">
              <tr><td colspan="3" class="muted">No sessions yet.</td></tr>
            </tbody>
          </table>
        </div>

        <div class="footnote">
          Tip: do it seated, same device, same time of day.
          Keyboard: <strong>Space</strong>.
        </div>
      </aside>
    </div>
  </div>

  <script>
    /********************************************************************
     * PVT 5 minutes (300s)
     * - Wait random ISI; then show a counter (ms) that increments quickly
     * - User taps/space ASAP: RT is time from onset to response
     * - False start: response during wait period
     * - Lapse: RT >= threshold (default 500ms)
     * - localStorage history + JSON export
     ********************************************************************/

    const CONFIG = {
      storageKey: "pvt5.v1",
      durationMs: 300000,
      counterTickMs: 10,  // display refresh
      minIsiMs: 2000,
      maxIsiMs: 10000
    };

    const el = {
      btnStart: document.getElementById("btnStart"),
      btnExport: document.getElementById("btnExport"),
      btnReset: document.getElementById("btnReset"),

      badgePhase: document.getElementById("badgePhase"),
      badgeTime: document.getElementById("badgeTime"),
      badgeLast: document.getElementById("badgeLast"),
      timeBar: document.getElementById("timeBar"),

      isiSelect: document.getElementById("isiSelect"),
      lapseSelect: document.getElementById("lapseSelect"),

      isiLabel: document.getElementById("isiLabel"),
      lapseLabel: document.getElementById("lapseLabel"),

      stage: document.getElementById("stage"),
      display: document.getElementById("display"),
      subtext: document.getElementById("subtext"),

      statTrials: document.getElementById("statTrials"),
      statMed: document.getElementById("statMed"),
      statMean: document.getElementById("statMean"),
      statLapses: document.getElementById("statLapses"),
      statFalse: document.getElementById("statFalse"),
      statFast: document.getElementById("statFast"),
      statSlow: document.getElementById("statSlow"),

      latestMed: document.getElementById("latestMed"),
      latestLapses: document.getElementById("latestLapses"),
      latestDate: document.getElementById("latestDate"),
      historyBody: document.getElementById("historyBody")
    };

    const state = {
      running: false,
      phase: "idle",  // idle | wait | go | done
      tStart: null,
      tEnd: null,

      // settings
      isiMin: 2000,
      isiMax: 10000,
      lapseMs: 500,

      // timers
      tickTimer: null,
      goTimer: null,
      counterTimer: null,
      goOnAt: null,

      // data
      trials: [], // {ts, isiMs, rtMs, lapse, falseStart}
      falseStarts: 0,
      lapses: 0,
      lastRT: null
    };

    function now() { return Date.now(); }
    function nowISO() { return new Date().toISOString(); }

    function fmtDate(iso) {
      try {
        const d = new Date(iso);
        return d.toLocaleString(undefined, { month:"short", day:"2-digit", hour:"2-digit", minute:"2-digit" });
      } catch { return iso; }
    }

    function median(arr) {
      if (!arr.length) return null;
      const a = arr.slice().sort((x,y) => x-y);
      const mid = Math.floor(a.length / 2);
      return (a.length % 2) ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }

    function mean(arr) {
      if (!arr.length) return null;
      return arr.reduce((s,x)=>s+x,0) / arr.length;
    }

    function percentile(arr, p) {
      if (!arr.length) return null;
      const a = arr.slice().sort((x,y)=>x-y);
      const idx = (a.length - 1) * p;
      const lo = Math.floor(idx);
      const hi = Math.ceil(idx);
      if (lo === hi) return a[lo];
      const w = idx - lo;
      return a[lo]*(1-w) + a[hi]*w;
    }

    function setBadge(elm, text, kind=null) {
      elm.textContent = text;
      elm.classList.remove("ok","bad");
      if (kind) elm.classList.add(kind);
    }

    function setProgressBar() {
      if (!state.running || !state.tStart || !state.tEnd) { el.timeBar.style.width = "0%"; return; }
      const frac = Math.max(0, Math.min(1, (now() - state.tStart) / (state.tEnd - state.tStart)));
      el.timeBar.style.width = (frac * 100).toFixed(1) + "%";
    }

    function updateTimeBadge() {
      if (!state.running || !state.tEnd) { setBadge(el.badgeTime, "Time: –"); return; }
      const remainMs = Math.max(0, state.tEnd - now());
      const remainSec = Math.ceil(remainMs / 1000);
      const m = Math.floor(remainSec / 60);
      const s = remainSec % 60;
      setBadge(el.badgeTime, `Time: ${m}:${String(s).padStart(2,"0")}`);
    }

    function loadSessions() {
      try {
        const raw = localStorage.getItem(CONFIG.storageKey);
        if (!raw) return [];
        const data = JSON.parse(raw);
        return Array.isArray(data) ? data : [];
      } catch { return []; }
    }
    function saveSessions(sessions) {
      localStorage.setItem(CONFIG.storageKey, JSON.stringify(sessions));
    }
    function addSession(session) {
      const sessions = loadSessions();
      sessions.unshift(session);
      saveSessions(sessions.slice(0, 200));
      renderHistory();
      renderLatest();
    }

    function renderLatest() {
      const sessions = loadSessions();
      const s = sessions[0] || null;
      el.latestMed.textContent = s && s.medianRtMs != null ? `${Math.round(s.medianRtMs)} ms` : "–";
      el.latestLapses.textContent = s ? String(s.lapses) : "–";
      el.latestDate.textContent = s ? fmtDate(s.completedAt) : "–";
    }

    function renderHistory() {
      const sessions = loadSessions();
      const body = el.historyBody;
      body.innerHTML = "";
      if (!sessions.length) {
        body.innerHTML = '<tr><td colspan="3" class="muted">No sessions yet.</td></tr>';
        return;
      }
      for (const s of sessions.slice(0, 6)) {
        const tr = document.createElement("tr");

        const tdDate = document.createElement("td");
        tdDate.textContent = fmtDate(s.completedAt);

        const tdMed = document.createElement("td");
        tdMed.className = "right";
        tdMed.textContent = (s.medianRtMs != null) ? `${Math.round(s.medianRtMs)} ms` : "–";

        const tdL = document.createElement("td");
        tdL.className = "right";
        tdL.textContent = String(s.lapses);

        tr.appendChild(tdDate);
        tr.appendChild(tdMed);
        tr.appendChild(tdL);
        body.appendChild(tr);
      }
    }

    function clearTimers() {
      if (state.tickTimer) clearInterval(state.tickTimer);
      if (state.counterTimer) clearInterval(state.counterTimer);
      if (state.goTimer) clearTimeout(state.goTimer);
      state.tickTimer = null;
      state.counterTimer = null;
      state.goTimer = null;
    }

    function setIdleUI() {
      setBadge(el.badgePhase, "Idle");
      setBadge(el.badgeTime, "Time: –");
      setBadge(el.badgeLast, "Last RT: –");

      el.display.textContent = "—";
      el.subtext.textContent = "Wait. When numbers appear, react as fast as you can. Do not tap before the numbers (false start).";

      el.statTrials.textContent = "0";
      el.statMed.textContent = "–";
      el.statMean.textContent = "–";
      el.statLapses.textContent = "0";
      el.statFalse.textContent = "0";
      el.statFast.textContent = "–";
      el.statSlow.textContent = "–";

      el.timeBar.style.width = "0%";
    }

    function applySettings() {
      const isiParts = (el.isiSelect.value || "2,10").split(",").map(x => parseInt(x,10));
      state.isiMin = Math.max(500, (isiParts[0]||2) * 1000);
      state.isiMax = Math.max(state.isiMin + 500, (isiParts[1]||10) * 1000);
      state.lapseMs = parseInt(el.lapseSelect.value, 10) || 500;

      el.isiLabel.textContent = `${Math.round(state.isiMin/1000)}–${Math.round(state.isiMax/1000)}`;
      el.lapseLabel.textContent = String(state.lapseMs);
    }

    function start() {
      applySettings();
      clearTimers();

      state.running = true;
      state.phase = "wait";
      state.tStart = now();
      state.tEnd = state.tStart + CONFIG.durationMs;

      state.trials = [];
      state.falseStarts = 0;
      state.lapses = 0;
      state.lastRT = null;

      setBadge(el.badgePhase, "Running", "ok");
      el.btnStart.textContent = "Stop";

      setProgressBar();
      updateTimeBadge();

      state.tickTimer = setInterval(() => {
        setProgressBar();
        updateTimeBadge();
        if (now() >= state.tEnd) finish();
      }, 120);

      // first trial
      el.display.textContent = "—";
      el.subtext.textContent = "Wait…";
      scheduleNextGo();
      updateStatsUI();
    }

    function finish() {
      if (!state.running) return;

      state.running = false;
      state.phase = "done";
      clearTimers();

      setBadge(el.badgePhase, "Done");
      el.btnStart.textContent = "Start";

      el.display.textContent = "—";
      el.subtext.textContent = "Session finished.";

      const rts = state.trials.filter(t => t.rtMs != null).map(t => t.rtMs);
      const med = median(rts);
      const mn = mean(rts);

      const fast10 = percentile(rts, 0.10);
      const slow90 = percentile(rts, 0.90);

      const session = {
        test: "PVT_5min",
        durationMs: CONFIG.durationMs,
        isiMinMs: state.isiMin,
        isiMaxMs: state.isiMax,
        lapseThresholdMs: state.lapseMs,
        trials: state.trials,
        trialsCount: state.trials.length,
        falseStarts: state.falseStarts,
        lapses: state.lapses,
        medianRtMs: med,
        meanRtMs: mn,
        fastest10pMs: fast10,
        slowest10pMs: slow90,
        completedAt: nowISO()
      };
      addSession(session);

      updateStatsUI();

      // keep time badge final
      setBadge(el.badgeTime, "Time: 0:00");
    }

    function scheduleNextGo() {
      if (!state.running) return;

      state.phase = "wait";
      el.display.textContent = "—";
      el.subtext.textContent = "Wait…";

      const isi = randInt(state.isiMin, state.isiMax);

      state.goTimer = setTimeout(() => {
        if (!state.running) return;
        showGo(isi);
      }, isi);
    }

    function showGo(isiMs) {
      state.phase = "go";
      state.goOnAt = now();

      // start counter
      el.subtext.textContent = "Tap now!";
      el.display.textContent = "000";

      if (state.counterTimer) clearInterval(state.counterTimer);
      state.counterTimer = setInterval(() => {
        const rt = now() - state.goOnAt;
        el.display.textContent = String(Math.max(0, rt)).padStart(3, "0");
      }, CONFIG.counterTickMs);

      // store isi so we can write it into the trial record on response
      state._pendingISI = isiMs;
    }

    function randInt(a, b) {
      return a + Math.floor(Math.random() * (b - a + 1));
    }

    function registerResponse(source="tap") {
      if (!state.running) return;

      const t = now();

      if (state.phase === "wait") {
        // false start
        state.falseStarts += 1;
        state.trials.push({
          ts: nowISO(),
          isiMs: null,
          rtMs: null,
          lapse: false,
          falseStart: true,
          source
        });
        setBadge(el.badgePhase, "False start", "bad");
        setTimeout(() => { if (state.running) setBadge(el.badgePhase, "Running", "ok"); }, 350);
        updateStatsUI();
        return;
      }

      if (state.phase !== "go") return;

      const rt = t - state.goOnAt;
      const lapse = rt >= state.lapseMs;

      // stop counter immediately
      if (state.counterTimer) clearInterval(state.counterTimer);
      state.counterTimer = null;

      state.lastRT = rt;
      setBadge(el.badgeLast, "Last RT: " + Math.round(rt) + " ms", lapse ? "bad" : "ok");

      if (lapse) state.lapses += 1;

      state.trials.push({
        ts: nowISO(),
        isiMs: state._pendingISI || null,
        rtMs: rt,
        lapse,
        falseStart: false,
        source
      });

      // brief feedback
      el.subtext.textContent = lapse ? "Lapse (slow). Keep going." : "Good. Keep going.";
      el.display.textContent = String(Math.round(rt)).padStart(3,"0");

      updateStatsUI();

      // small pause then next trial
      state.phase = "wait";
      setTimeout(() => {
        if (!state.running) return;
        scheduleNextGo();
      }, 350);
    }

    function updateStatsUI() {
      const rts = state.trials.filter(t => t.rtMs != null).map(t => t.rtMs);
      const med = median(rts);
      const mn = mean(rts);

      const fast10 = percentile(rts, 0.10);
      const slow90 = percentile(rts, 0.90);

      el.statTrials.textContent = String(state.trials.length);
      el.statMed.textContent = med != null ? `${Math.round(med)} ms` : "–";
      el.statMean.textContent = mn != null ? `${Math.round(mn)} ms` : "–";
      el.statLapses.textContent = String(state.lapses);
      el.statFalse.textContent = String(state.falseStarts);
      el.statFast.textContent = fast10 != null ? `${Math.round(fast10)} ms` : "–";
      el.statSlow.textContent = slow90 != null ? `${Math.round(slow90)} ms` : "–";
    }

    function exportJSON() {
      const sessions = loadSessions();
      const blob = new Blob([JSON.stringify(sessions, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pvt5-sessions.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // Events
    el.btnStart.addEventListener("click", () => {
      if (state.running) { finish(); return; }
      start();
    });

    el.btnExport.addEventListener("click", exportJSON);

    el.btnReset.addEventListener("click", () => {
      localStorage.removeItem(CONFIG.storageKey);
      renderHistory();
      renderLatest();
    });

    el.stage.addEventListener("click", () => registerResponse("tap"));

    window.addEventListener("keydown", (e) => {
      if (e.key === " " || e.code === "Space") {
        e.preventDefault();
        registerResponse("space");
      }
    });

    // Init
    (function init() {
      applySettings();
      setIdleUI();
      renderHistory();
      renderLatest();
    })();
  </script>
</body>
</html>
